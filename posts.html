<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Bit Coder</title>
</head>
<body>
    <header>
    <div class="nav_box">
        <div class="nav_logo_box">
            <div class="logo"></div>
            <h1>BIT CODER</h1>
        </div>
        <div id="box2" class="nav_links">
<a href="index.html"> <h1>HOME</h1></a>
           <a href="about.html"> <h1>ABOUT</h1></a>
            <a href="posts.html"><h1>POSTS</h1></a>
           <a href="contact.html"><h1>CONTACT</h1></a>
        </div>
<div id="box" >
    <div class="line"></div>
    <div class="line"></div>
    <div class="line"></div>
</div>
         </div>



<main>
    <div class="side2">
        <div id="post-lists">
<!-- hear element aa -->
        </div>
    </div>
<div class="post-nav">
    <p id="post-lists-box">POSTS<</p>
    <h1>POSTS</h1>
</div>
    <div id="all-page-content">
        <!-- content hear add -->


        <div class="content-of-page">
            <h1 id="post1" class="main-post-heading">JSON (JavaScript Object Notation)</h1>
            <p>JSON is a lightweight data-interchange format that stores data in key-value pairs. It is human-readable and easily parsable and processable by machines.</p>

            <h2>How to Create a JSON File?</h2>
            <p>A JSON file is created with the `.json` extension. Its content must follow a structured format using keys and values.</p>
            <p>Example JSON File:</p>
            <pre >
                {
                    "name": "John Doe",
                    "age": 30,
                    "isEmployed": true,
                    "skills": ["JavaScript", "Python", "C++"],
                    "address": {
                        "city": "New York",
                        "zip": "10001"
                    }
                }
            </pre>

            <h2>Why Use JSON?</h2>
            <p>JSON is mainly used to store and exchange data. It is platform-independent and ideal for web applications.</p>
            <p>Some reasons include:</p>
            <ul>
                <li>Lightweight and fast</li>
                <li>Human-readable format</li>
                <li>Cross-platform compatibility</li>
                <li>Easy to parse and process</li>
            </ul>

            <h2>When to Use JSON?</h2>
            <p>JSON is used in various scenarios:</p>
            <ul>
                <li>Web Development (data transfer between server and client)</li>
                <li>Configuration Files (storing software settings)</li>
                <li>APIs (as response and request format)</li>
                <li>Data Storage (lightweight data storage)</li>
            </ul>

            <h2>Importing JSON</h2>
            <p>To import a JSON file, different programming languages use predefined methods. For example:</p>
            <h2>Python:</h2>
            <p>Import and parse:</p>
            <pre >
                import json

                with open('data.json') as file:
                    data = json.load(file) # Converts JSON file to Python dictionary
                    print(data['name']) # Output: John Doe
            </pre>
            <h2>JavaScript:</h2>
            <p>Loading a JSON file with Fetch API:</p>
            <pre>
                fetch('data.json')
                    .then(response => response.json())
                    .then(data => console.log(data.name)); // Output: John Doe
            </pre>

            <h2>Managing JSON Data</h2>
            <p>Managing JSON data is easy. We can read, update, and delete data using programming languages.</p>
            <p>Example: Updating data in Python:</p>
            <pre>
                data['age'] = 31
            </pre>

            <h2>Accessing JSON Data</h2>
            <p>JSON data can be accessed using keys. Example:</p>
            <h2>JavaScript:</h2>
            <pre>
                console.log(data.name); // Output: John Doe
            </pre>
            <h2>Python:</h2>
            <pre>
                print(data['name']) # Output: John Doe
            </pre>

            <h2>Basic to Advanced JSON Concepts</h2>
            <p>Basic:</p>
            <ul>
                <li>Key-Value Pair</li>
                <li>Arrays and Objects</li>
                <li>Null, Boolean, and Number types</li>
            </ul>
            <p>Advanced:</p>
            <ul>
                <li>Nested JSON Objects</li>
                <li>Dynamic JSON generation</li>
                <li>Streaming JSON data</li>
                <li>Serialization and Deserialization</li>
            </ul>

            <h2>Conclusion</h2>
            <p>JSON is a powerful format widely used in modern applications. It is ideal for exchanging data and lightweight storage. Various programming languages effectively utilize JSON.</p>

        </div>
        <div class="content-of-page">
            <h1 id="post2" class="main-post-heading">Complete JavaScript DOM Manipulation Guide</h1>

<h2>1. Selecting Elements in DOM</h2>

<h3>a. Selecting Single Element</h3>
<pre>
// Select by ID
const header = document.getElementById('header');

// Select using CSS selector (first matching element)
const item = document.querySelector('.item');
</pre>

<h3>b. Selecting Multiple Elements</h3>
<pre>
// By class name
const items = document.getElementsByClassName('item');

// By tag name
const paragraphs = document.getElementsByTagName('p');

// All matching elements using CSS selector
const allItems = document.querySelectorAll('.item');
</pre>

<h2>2. Creating and Adding Elements</h2>

<h3>a. Creating New Element</h3>
<pre>
const newDiv = document.createElement('div');
newDiv.textContent = 'New Div';
</pre>

<h3>b. Ways to Add to DOM</h3>
<pre>
// Append at the end
document.body.appendChild(newDiv);

// Insert at specific position
const container = document.getElementById('container');
container.insertBefore(newDiv, container.firstChild);

// Insert HTML inside element
container.innerHTML = '&lt;p&gt;New paragraph&lt;/p&gt;';
</pre>

<h2>3. Modifying Elements</h2>

<h3>a. Changing Content</h3>
<pre>
// Change text content
const heading = document.querySelector('h1');
heading.textContent = 'New Heading';

// Change HTML content
heading.innerHTML = 'New &lt;em&gt;Heading&lt;/em&gt;';
</pre>

<h3>b. Changing Attributes</h3>
<pre>
const link = document.querySelector('a');

// Using setAttribute method
link.setAttribute('href', 'https://newurl.com');

// Direct property access
link.href = 'https://newurl.com';
</pre>

<h3>c. Changing Styles</h3>
<pre>
const box = document.querySelector('.box');
box.style.backgroundColor = 'blue';
box.style.padding = '20px';
</pre>

<h3>d. Managing Classes</h3>
<pre>
// Add class
box.classList.add('active');

// Remove class
box.classList.remove('inactive');

// Toggle class
box.classList.toggle('hidden');
</pre>

<h2>4. Deleting Elements</h2>
<pre>
const elementToRemove = document.querySelector('.old-element');

// Modern way
elementToRemove.remove();

// Older way (for browser support)
elementToRemove.parentNode.removeChild(elementToRemove);
</pre>

<h2>5. Adding Event Listeners</h2>
<pre>
const button = document.querySelector('button');

button.addEventListener('click', function() {
  console.log('Button clicked!');
});
</pre>

<h2>6. Accessing Form Values</h2>
<pre>
const form = document.querySelector('form');
const input = document.querySelector('input[type="text"]');

form.addEventListener('submit', function(event) {
  event.preventDefault();
  console.log(input.value);
});
</pre>

<h2>Practical Example - Todo List</h2>
<pre>
&lt;div id="app"&gt;
  &lt;input type="text" id="taskInput" placeholder="New task"&gt;
  &lt;button id="addBtn"&gt;Add&lt;/button&gt;
  &lt;ul id="taskList"&gt;&lt;/ul&gt;
&lt;/div&gt;

&lt;script&gt;
  const input = document.getElementById('taskInput');
  const addBtn = document.getElementById('addBtn');
  const list = document.getElementById('taskList');

  addBtn.addEventListener('click', () => {
    if (input.value.trim() === '') return;

    const li = document.createElement('li');
    li.textContent = input.value;

    const deleteBtn = document.createElement('button');
    deleteBtn.textContent = 'Delete';
    deleteBtn.addEventListener('click', () => li.remove());

    li.appendChild(deleteBtn);
    list.appendChild(li);

    input.value = '';
    input.focus();
  });
&lt;/script&gt;
</pre>

<h2>Advanced DOM Manipulation Techniques</h2>

<h3>1. Event Delegation</h3>
<pre>
document.getElementById('taskList').addEventListener('click', function(e) {
  if(e.target.tagName === 'BUTTON') {
    e.target.parentElement.remove();
  }
});
</pre>

<h3>2. Element Cloning</h3>
<pre>
const template = document.querySelector('.template');
const newItem = template.cloneNode(true);
newItem.style.display = 'block';
document.body.appendChild(newItem);
</pre>

<h3>3. Using Dataset Attributes</h3>
<pre>
&lt;div data-user-id="123" data-role="admin"&gt;User Info&lt;/div&gt;

&lt;script&gt;
  const userDiv = document.querySelector('div');
  console.log(userDiv.dataset.userId); // "123"
  console.log(userDiv.dataset.role); // "admin"
&lt;/script&gt;
</pre>

<h2>Performance Tips</h2>
<ul>
  <li><strong>Minimize DOM Access:</strong> Select elements once and store in variables</li>
  <li><strong>Batch DOM Updates:</strong> Use DocumentFragment</li>
  <li><strong>Event Delegation:</strong> Attach listeners to parent elements</li>
</ul>

<pre>
// DocumentFragment example
const fragment = document.createDocumentFragment();

for(let i = 0; i &lt; 100; i++) {
  const li = document.createElement('li');
  li.textContent = `Item ${i}`;
  fragment.appendChild(li);
}

document.getElementById('list').appendChild(fragment);
</pre>

<p>DOM manipulation is JavaScript's most powerful feature that enables you to dynamically modify web pages. These techniques will help you build interactive web applications.</p>

        </div>
<div class="content-of-page">

 <h1 id="post3" class="main-post-heading">Automata Theory Fundamentals</h1>

<h2>1. Introduction to Automata Theory</h2>
<p>Automata theory is the study of abstract machines and the computational problems that can be solved using these machines. It forms the theoretical foundation of computer science and is closely related to formal language theory.</p>

<div class="note">
    <strong>Key Concept:</strong> Automata are mathematical models of computation that perform tasks on given inputs by transitioning through a series of states.
</div>

<h2>2. Types of Automata</h2>

<h3>2.1 Finite Automata (FA)</h3>
<p>Finite automata are the simplest type of automaton with a finite number of states.</p>

<pre>
// Formal definition of a Finite Automaton
FA = (Q, Σ, δ, q₀, F)
Where:
Q = Finite set of states
Σ = Finite set of input symbols (alphabet)
δ = Transition function (Q × Σ → Q)
q₀ = Initial state (q₀ ∈ Q)
F = Set of final/accepting states (F ⊆ Q)
</pre>

<h4>Types of Finite Automata:</h4>
<ul>
    <li><strong>Deterministic Finite Automaton (DFA):</strong> Exactly one transition for each symbol in each state</li>
    <li><strong>Nondeterministic Finite Automaton (NFA):</strong> May have multiple transitions for a symbol in a state</li>
</ul>

<h3>2.2 Pushdown Automata (PDA)</h3>
<p>An extension of finite automata that includes a stack for memory.</p>

<pre>
// Formal definition of a Pushdown Automaton
PDA = (Q, Σ, Γ, δ, q₀, Z₀, F)
Where:
Γ = Stack alphabet
Z₀ = Initial stack symbol
δ = Transition function (Q × (Σ ∪ {ε}) × Γ → finite subsets of Q × Γ*)
</pre>

<h3>2.3 Turing Machines</h3>
<p>The most powerful automaton that can simulate any computer algorithm.</p>

<pre>
// Formal definition of a Turing Machine
TM = (Q, Σ, Γ, δ, q₀, B, F)
Where:
Γ = Tape alphabet (Σ ⊆ Γ)
B = Blank symbol (B ∈ Γ \ Σ)
δ = Transition function (Q × Γ → Q × Γ × {L, R})
</pre>

<h2>3. Applications of Automata Theory</h2>

<ul>
    <li><strong>Compiler Design:</strong> Lexical analysis and parsing</li>
    <li><strong>Text Processing:</strong> Regular expressions for pattern matching</li>
    <li><strong>Software Verification:</strong> Model checking of finite-state systems</li>
    <li><strong>Artificial Intelligence:</strong> State machines for AI behavior</li>
    <li><strong>Network Protocols:</strong> Protocol state machines</li>
</ul>

<h2>4. Formal Languages Hierarchy</h2>

<p>The Chomsky hierarchy classifies formal grammars and their corresponding automata:</p>

<table border="1" cellpadding="5" cellspacing="0">
    <tr>
        <th>Type</th>
        <th>Grammar</th>
        <th>Automaton</th>
        <th>Language</th>
    </tr>
    <tr>
        <td>Type 0</td>
        <td>Unrestricted</td>
        <td>Turing Machine</td>
        <td>Recursively enumerable</td>
    </tr>
    <tr>
        <td>Type 1</td>
        <td>Context-sensitive</td>
        <td>Linear-bounded automaton</td>
        <td>Context-sensitive</td>
    </tr>
    <tr>
        <td>Type 2</td>
        <td>Context-free</td>
        <td>Pushdown automaton</td>
        <td>Context-free</td>
    </tr>
    <tr>
        <td>Type 3</td>
        <td>Regular</td>
        <td>Finite automaton</td>
        <td>Regular</td>
    </tr>
</table>

<h2>5. Practical Examples</h2>

<h3>5.1 DFA Example - Binary Numbers Divisible by 3</h3>

<pre>
// States: q0 (remainder 0), q1 (remainder 1), q2 (remainder 2)
// Alphabet: {0, 1}
// Transition table:
// δ(q0, 0) = q0
// δ(q0, 1) = q1
// δ(q1, 0) = q2
// δ(q1, 1) = q0
// δ(q2, 0) = q1
// δ(q2, 1) = q2
// Accepting state: q0
</pre>

<h3>5.2 Turing Machine Example - Palindrome Checker</h3>

<pre>
1. Move to the end of the input (right of the last symbol)
2. Compare first and last symbols
   - If equal, mark both (with special symbols) and move inward
   - If not equal, reject
3. Repeat until all symbols are marked or middle is reached
4. If all comparisons were equal, accept
</pre>

<h2>6. Computational Power</h2>

<p>The hierarchy of computational power:</p>
<ol>
    <li>Finite Automata (Regular languages)</li>
    <li>Pushdown Automata (Context-free languages)</li>
    <li>Linear Bounded Automata (Context-sensitive languages)</li>
    <li>Turing Machines (Recursively enumerable languages)</li>
</ol>

<div class="note">
    <strong>Church-Turing Thesis:</strong> Any computation that can be performed by an algorithm can be performed by a Turing machine.
</div>

<h2>7. Limitations of Automata</h2>

<ul>
    <li><strong>Finite Automata:</strong> Cannot count or remember arbitrary amounts of information</li>
    <li><strong>Pushdown Automata:</strong> Cannot handle multiple stacks or more complex memory</li>
    <li><strong>Turing Machines:</strong> Some problems are undecidable (e.g., Halting Problem)</li>
</ul>

<h2>8. Tools and Software</h2>

<p>Popular tools for working with automata:</p>
<ul>
    <li><strong>JFLAP:</strong> Java-based tool for experimenting with automata</li>
    <li><strong>JFLAP:</strong> Java Formal Languages and Automata Package</li>
    <li><strong>Automata Tutor:</strong> Web-based learning tool</li>
    <li><strong>JFLAP:</strong> Visualization of finite automata and grammars</li>
</ul>

<h2>9. Further Reading</h2>

<ul>
    <li>"Introduction to the Theory of Computation" by Michael Sipser</li>
    <li>"Automata Theory, Languages, and Computation" by Hopcroft, Motwani, and Ullman</li>
    <li>"Elements of the Theory of Computation" by Harry Lewis and Christos Papadimitriou</li>
</ul>              
        </div>

<div class="content-of-page">
 <h1 id="post4" class="main-post-heading">
   

    
    Complete JavaScript DOM Manipulation Guide</h1>
    
    <p>DOM manipulation is essential for creating interactive web pages. This guide covers all key concepts with practical examples.</p>

    <h2>1. Selecting Elements</h2>
    
    <h3>Basic Selectors</h3>
    <div class="code-block">
// By ID - returns single element
const element = document.getElementById('header');

// By class name - returns HTMLCollection
const elements = document.getElementsByClassName('menu-item');

// By tag name - returns HTMLCollection
const divs = document.getElementsByTagName('div');

// Query selector - returns first match
const firstMatch = document.querySelector('.special');

// Query selector all - returns NodeList
const allMatches = document.querySelectorAll('.item');
    </div>
    
    <div class="explanation">
        <p><strong>How it works:</strong> These are the fundamental methods to select elements. <code>getElementById</code> is fastest, while <code>querySelector</code> offers CSS selector flexibility. HTMLCollections are live (update automatically), while NodeLists are static by default.</p>
    </div>
    
    <div class="demo-area">
        <div id="demo-header">Header Element</div>
        <div class="demo-item">Item 1</div>
        <div class="demo-item">Item 2</div>
        <button onclick="demoSelectors()">Test Selectors</button>
        <div id="selector-output"></div>
    </div>

    <h2>2. Traversing the DOM</h2>
    
    <h3>Navigating Between Nodes</h3>
    <div class="code-block">
// Parent nodes
const parent = childElement.parentNode;
const parentElement = childElement.parentElement;

// Child nodes
const children = parent.childNodes; // Includes text nodes
const childrenElements = parent.children; // Only elements

// Siblings
const next = element.nextElementSibling;
const prev = element.previousElementSibling;
    </div>
    
    <div class="explanation">
        <p><strong>How it works:</strong> DOM traversal lets you navigate between elements without reselecting. <code>childNodes</code> includes text nodes (whitespace), while <code>children</code> only includes element nodes.</p>
    </div>
    
    <div class="demo-area" id="traversal-demo">
        <div>First Child</div>
        <div id="traversal-target">Target Element (Middle Child)</div>
        <div>Last Child</div>
        <button onclick="demoTraversal()">Test Traversal</button>
    </div>

    <h2>3. Modifying Elements</h2>
    
    <h3>Changing Content and Attributes</h3>
    <div class="code-block">
// Content modification
element.innerHTML = '&lt;strong&gt;Bold text&lt;/strong&gt;';
element.textContent = 'Plain text only';

// Attribute manipulation
element.setAttribute('data-id', '123');
const value = element.getAttribute('data-id');
element.removeAttribute('title');

// Class manipulation
element.classList.add('active');
element.classList.remove('inactive');
element.classList.toggle('visible');

// Style changes
element.style.color = 'blue';
element.style.marginTop = '10px';
    </div>
    
    <div class="explanation">
        <p><strong>How it works:</strong> <code>innerHTML</code> parses HTML, while <code>textContent</code> is safer against XSS. Class manipulation is preferred over direct <code>className</code> assignment. Style properties use camelCase.</p>
    </div>
    
    <div class="demo-area">
        <div id="content-demo">Original Content</div>
        <div id="attr-demo" class="original" title="Hover text">Attribute Demo</div>
        <button onclick="demoModification()">Test Modification</button>
    </div>

    <h2>4. Creating and Adding Elements</h2>
    
    <h3>Dynamic Element Creation</h3>
    <div class="code-block">
// Create new element
const newDiv = document.createElement('div');
newDiv.textContent = 'New Element';

// Append to parent
parent.appendChild(newDiv);

// Insert at specific position
parent.insertBefore(newDiv, referenceElement);

// Insert adjacent HTML
element.insertAdjacentHTML('beforeend', '&lt;div&gt;After&lt;/div&gt;');
    </div>
    
    <div class="explanation">
        <p><strong>How it works:</strong> <code>createElement</code> makes elements in memory. They only appear on page when added to DOM. <code>insertAdjacentHTML</code> offers precise positioning (beforebegin, afterbegin, beforeend, afterend).</p>
    </div>
    
    <div class="demo-area">
        <div id="element-container"></div>
        <button onclick="demoCreateElements()">Create Elements</button>
    </div>

    <h2>5. Event Handling</h2>
    
    <h3>Event Listeners and Delegation</h3>
    <div class="code-block">
// Add event listener
button.addEventListener('click', function(event) {
    console.log('Clicked!', event.target);
});

// Event delegation
document.addEventListener('click', function(event) {
    if (event.target.matches('.dynamic-item')) {
        console.log('Dynamic item clicked');
    }
});

// Remove event listener
const handler = function() { console.log('Only once'); };
element.addEventListener('click', handler, { once: true });
    </div>
    
    <div class="explanation">
        <p><strong>How it works:</strong> Event delegation attaches listeners to parent elements, useful for dynamic content. The <code>once</code> option auto-removes after firing. Always remove listeners when no longer needed.</p>
    </div>
    
    <div class="demo-area">
        <button id="click-demo">Click Me</button>
        <div id="event-output"></div>
        <div id="event-delegation">
            <div class="dynamic-item">Item 1</div>
            <div class="dynamic-item">Item 2</div>
        </div>
        <button onclick="addNewItem()">Add New Item</button>
    </div>

    <h2>6. Working with Forms</h2>
    
    <h3>Form Handling</h3>
    <div class="code-block">
// Form submission
form.addEventListener('submit', function(event) {
    event.preventDefault();
    const formData = new FormData(form);
    
    // Get values
    const username = formData.get('username');
    
    // Process data
    console.log(Array.from(formData.entries()));
});

// Input events
input.addEventListener('input', function() {
    console.log('Value changed:', this.value);
});
    </div>
    
    <div class="explanation">
        <p><strong>How it works:</strong> <code>FormData</code> provides easy access to form values. <code>preventDefault()</code> stops page reload. Input events fire on each change (unlike change event which fires after blur).</p>
    </div>
    
    <div class="demo-area">
        <form id="sample-form">
            <div class="form-group">
                <input type="text" name="username" placeholder="Username">
            </div>
            <div class="form-group">
                <input type="email" name="email" placeholder="Email">
            </div>
            <button type="submit">Submit</button>
        </form>
        <div id="form-output"></div>
    </div>

    <h2>7. Performance Considerations</h2>
    
    <h3>Optimizing DOM Operations</h3>
    <div class="code-block">
// Document Fragment for batch additions
const fragment = document.createDocumentFragment();
for (let i = 0; i < 100; i++) {
    const div = document.createElement('div');
    fragment.appendChild(div);
}
document.body.appendChild(fragment);

// Debouncing events
let timeout;
window.addEventListener('resize', function() {
    clearTimeout(timeout);
    timeout = setTimeout(function() {
        // Handle resize
    }, 200);
});
    </div>
    
    <div class="explanation">
        <p><strong>How it works:</strong> Document fragments prevent layout thrashing by batching changes. Debouncing limits how often expensive operations run. Also consider throttling for different use cases.</p>
    </div>
    
    <div class="demo-area">
        <button onclick="demoPerformance()">Add 100 Elements</button>
        <div id="performance-demo"></div>
    </div>

           

</div>


       </div>
   </main>


<footer>
<p>&copy;Copyright  2025 Bit Coder. All rights reserved. <br> Develop by Shivam Kumar</p>
</footer>
<script src="blogpost.js">

</script>
</body>
</html>
